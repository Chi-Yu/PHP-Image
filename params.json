{"name":"PHP_Image","tagline":"Encapsulates common GD library operations in PHP classes.","body":"[![Build Status](https://travis-ci.org/Random-Host/PHP_Image.svg)](https://travis-ci.org/Random-Host/PHP_Image)\r\n\r\nIntroduction\r\n------------\r\n\r\nThis package encapsulates some common GD library operations in PHP classes. It\r\nwas created as part of the PHP_Webcam_Overlay package but is released as a\r\nseparate component so it can be used in other packages.\r\n\r\nBecause it was created as a dependency of the PHP_Webcam_Overlay package, it\r\ndoes only support a small subset of the available image handling functions.\r\n\r\nUsage\r\n-----\r\n\r\nA basic approach at using this package could look like this:\r\n\r\n```php\r\n<?php\r\nnamespace randomhost\\Image;\r\n\r\nrequire 'psr0.autoloader.php';\r\n\r\n// load base image\r\n$image = Image::getInstanceByPath('image.png');\r\n\r\n// load overlay image\r\n$overlay = Image::getInstanceByPath('overlay.png');\r\n\r\n// insert overlay image on top of base image at x 15, y 20\r\n$image->merge($overlay, 15, 20);\r\n\r\n// setup a red text overlay\r\n$text = new Text\\Generic($image);\r\n$text\r\n    ->setTextFont('vera.ttf')\r\n    ->setTextSize(12)\r\n    ->setTextColor(\r\n        new Color(\r\n            0xFF,\r\n            0x00,\r\n            0x00\r\n        )\r\n    );\r\n\r\n// setup a white border for the previously defined text overlay\r\n$text = new Text\\Decorator\\Border($text);\r\n$text->setBorderColor(\r\n    new Color(\r\n        0xFF,\r\n        0xFF,\r\n        0xFF\r\n    )\r\n);\r\n\r\n// render text overlay onto the image at x 20, y 10\r\n$text->insertText(\r\n    20,\r\n    10,\r\n    'Example text'\r\n);\r\n\r\n// render the image\r\n$image->render()\r\n```\r\n\r\nThis will instantiate two image objects using image files from the file system,\r\nmerge the images and render an overlay text on top.\r\n\r\nAssuming that you named this file `image.php`, you should now be able to\r\naccess the image at `http://example.com/image.php`\r\n\r\n### The Image object\r\n\r\nThe `Image` object represents an image in a (remote) filesystem or created in\r\nmemory. It provides methods for retrieving information about the image and for\r\nmerging other `Image` instances.\r\n\r\n#### Instantiation\r\n\r\nThere are two methods for creating an `Image` object instance:\r\n\r\n1. `Image::getInstanceByPath($path, $cacheDir = '')`  \r\n   Creates an instance from an existing local or remote image file.\r\n     - `$path`  \r\n     Path or URL to the image file.\r\n     - `$cacheDir`  \r\n     Optional: Directory path for caching image files.  \r\n     This comes in handy when retrieving images from remote locations as caching\r\n     them locally reduces the amount of HTTP requests which have to be made.\r\n2. `Image::getInstanceByCreate($width, $height)`  \r\n     Creates an empty instance with the given image dimensions which can be used\r\n     to merge (multiple) other `Image` instances into it.\r\n     - `$width`  \r\n     Width of the generated image.\r\n     - `$height`  \r\n     Height of the generated image.\r\n\r\n#### Retrieving image data\r\n\r\nThe following public methods for retrieving image related data are available:\r\n\r\n- `getMimetype()`  \r\nReturns the Mimetype of the image.\r\n- `getModified()`  \r\nReturns the last modified timestamp of the image. When working with an instance\r\ncreated with `getInstanceByCreate()`, this will be the time when the object was\r\ninitially created.\r\n- `getWidth()`  \r\nReturns the width of the image in pixels.\r\n- `getHeight()`  \r\nReturns the height of the image in pixels.\r\n\r\n#### Combining images\r\n\r\n- `merge(Image $srcImage, $dstX, $dstY, $strategy = self::MERGE_SCALE_SRC)`  \r\nMerges the image resource of the given `Image` instance into the image resource\r\nof the active `Image` instance using the given coordinates and scaling strategy.\r\n- `mergeAlpha(Image $srcImage, $dstX, $dstY, $alpha = 127)`  \r\nMerges the image resource of the given `Image` instance into the image resource\r\nof the active `Image` instance using the given coordinates and alpha transparency.\r\nThis method does not support scaling.\r\n\r\n#### Scaling strategies\r\n\r\n- `Image::MERGE_SCALE_SRC`  \r\nThis strategy uses width and height of the `Image` instance given to `merge()`.\r\nIf the image to be merged exceeds the dimensions of the target instance, it is\r\ncropped to fit the dimensions of the target instance.\r\n- `Image::MERGE_SCALE_DST`  \r\nThis strategy re-sizes the `Image` instance given to `merge()` to match the\r\ndimensions of the target instance. The x and y offset given to `merge()` will\r\nhowever not be respected so the image to be merged may still be cropped.\r\n- `Image::MERGE_SCALE_DST_NO_UPSCALE`  \r\nThis strategy works similar to `Image::MERGE_SCALE_DST`, but does not upscale\r\nthe image to be merged if it is smaller than the target instance.\r\n\r\n#### Rendering the image\r\n\r\n- `render()`  \r\nOutputs the image stream to the browser. For now, images will always be rendered\r\nas `image/png` to allow for full alpha-transparency support. Support for other\r\nformats may be added in a later version.\r\n\r\n### The Color object\r\n\r\nThe `Color` object is merely a data container for defining color values to be\r\nused within the `PHP_Image` package. It comes with a set of setters and getters\r\nfor setting and retrieving color and alpha channel data.\r\n\r\n#### Constructor\r\n\r\nThe constructor takes 4 parameters which are all optional:\r\n\r\n- `$red`  \r\nRed component (0-255 or 0x00-0xFF).\r\n- `$green`  \r\nGreen component (0-255 or 0x00-0xFF).\r\n- `$blue`  \r\nBlue component (0-255 or 0x00-0xFF).\r\n- `$alpha`  \r\nAlpha value (0-127)\r\n\r\n#### Configuring the color\r\n\r\n- `setRed($red)`  \r\nSets the red component (0-255 or 0x00-0xFF).\r\n- `setGreen($green)`  \r\nSets the green component (0-255 or 0x00-0xFF).\r\n- `setBlue($blue)`  \r\nSets the blue component (0-255 or 0x00-0xFF).\r\n- `setAlpha($alpha)`  \r\nSets the alpha value (0-127). 0 indicates completely opaque while 127 indicates\r\ncompletely transparent.\r\n\r\n#### Retrieving color data\r\n\r\n- `getRed()`  \r\nReturns the red component (0-255 or 0x00-0xFF).\r\n- `getGreen()`  \r\nReturns the green component (0-255 or 0x00-0xFF).\r\n- `getBlue()`  \r\nReturns the blue component (0-255 or 0x00-0xFF).\r\n- `getAlpha()`  \r\nReturns the alpha value (0-127). 0 indicates completely opaque while 127\r\nindicates completely transparent.\r\n\r\n#### Validating color data\r\n\r\n- `Color::validateColor($color)`  \r\nValidates the color value and throws an InvalidArgumentException if the value is\r\ninvalid.\r\n- `Color::validateAlpha($alpha)`  \r\nValidates the alpha value and throws an InvalidArgumentException if the value is\r\ninvalid.\r\n\r\n### The Image/Text/Generic object\r\n\r\nThe `Image/Text/Generic` object is a generic text rendering object which can be\r\nextended with additional functionality using decorators.\r\n\r\n#### Constructor\r\n\r\nThe constructor takes 1 optional parameter:\r\n\r\n- `$image`  \r\nAn `Image` instance to operate on. This can also be set later using the\r\n`setImage()` method.\r\n\r\n#### Configuring the text\r\n\r\n- `setImage(Image\\Image $image)`  \r\nSets the `Image` object instance.\r\n- `setTextColor(Image\\Color $color)`  \r\nSets the `Color` used for rendering the text.\r\n- `setTextFont($path)`  \r\nSets the path to the font file used for rendering.\r\n- `setTextSize($size)`  \r\nSets the text size used for rendering.\r\n\r\n#### Retrieving text data\r\n\r\n- `getImage()`  \r\nReturns the `Image` object instance.\r\n- `getTextColor()`  \r\nReturns the `Color` used for rendering the text.\r\n- `getTextFont()`  \r\nReturns the path to the font file used for rendering.\r\n- `getTextSize()`  \r\nReturns the text size used for rendering.\r\n\r\n#### Rendering the text\r\n\r\n- `insertText($xPosition, $yPosition, $text)`  \r\nRenders the given text onto the image resource, using the given coordinates.\r\n\r\n### The Image/Text/Decorator object family\r\n\r\nThe `Image/Text/Decorator` object family contains decorators for text rendering\r\nobjects which add additional functionality to the `Image/Text/Generic` object or\r\nother objects implementing the `Image\\Text\\Text` interface.\r\n\r\nSince they wrap around any `Image\\Text\\Text` implementation which could also be\r\nanother `Image/Text/Decorator` instance, they share all methods of the decorated\r\nobject and might also define their own.\r\n\r\n#### Constructor\r\n\r\nThe constructor depends on the specific `Image/Text/Decorator` implementation\r\nbut usually takes at least one parameter which is the object to decorate:\r\n\r\n- `$text`  \r\nAn `Image\\Text\\Text` implementation to decorate.\r\n\r\n#### Retrieving text decorator data\r\n\r\n- `providesMethod($name)`  \r\nReturns if the given method is implemented by one of the decorators in the\r\nobject tree as decorators can be stacked.\r\n\r\n#### Rendering text using a decorator\r\n\r\nSince all decorators implement the same interface as the standard\r\n`Image/Text/Generic` object, rendering using decorated text objects works the\r\nsame way as rendering using non-decorated objects:\r\n\r\n- `insertText($xPosition, $yPosition, $text)`  \r\nRenders the given text onto the image resource, using the given coordinates.\r\n\r\n### The Image/Text/Decorator/Border object\r\n\r\nThe `Image/Text/Decorator/Border` object is a decorator for text rendering\r\nobjects which adds a simple border to the rendered text.\r\n\r\n#### Configuring the border\r\n\r\n- `setBorderColor(Image\\Color $color)`  \r\nSets the `Color` used for rendering the border.\r\n\r\n#### Retrieving border data\r\n\r\n- `getBorderColor()`  \r\nReturns the `Color` used for rendering the border.\r\n\r\nSystem-Wide Installation\r\n------------------------\r\n\r\nPHP_Image should be installed using the [PEAR Installer](http://pear.php.net).\r\nThis installer is the PHP community's de-facto standard for installing PHP\r\ncomponents.\r\n\r\n    sudo pear channel-discover pear.random-host.com\r\n    sudo pear install --alldeps randomhost/PHP_Image\r\n\r\nAs A Dependency On Your Component\r\n---------------------------------\r\n\r\nIf you are creating a component that relies on PHP_Image, please make sure that\r\nyou add PHP_Image to your component's package.xml file:\r\n\r\n```xml\r\n<dependencies>\r\n  <required>\r\n    <package>\r\n      <name>PHP_Image</name>\r\n      <channel>pear.random-host.com</channel>\r\n      <min>1.0.0</min>\r\n      <max>1.999.9999</max>\r\n    </package>\r\n  </required>\r\n</dependencies>\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nThe best documentation for PHP_Image are the unit tests, which are shipped in\r\nthe package. You will find them installed into your PEAR repository, which on\r\nLinux systems is normally /usr/share/php/test.\r\n\r\nDevelopment Environment\r\n-----------------------\r\n\r\nIf you want to patch or enhance this component, you will need to create a\r\nsuitable development environment. The easiest way to do that is to install\r\nphix4componentdev:\r\n\r\n    # phix4componentdev\r\n    sudo apt-get install php5-xdebug\r\n    sudo apt-get install php5-imagick\r\n    sudo pear channel-discover pear.phix-project.org\r\n    sudo pear -D auto_discover=1 install -Ba phix/phix4componentdev\r\n\r\nYou can then clone the git repository:\r\n\r\n    # PHP_Webcam_Overlay\r\n    git clone https://github.com/Random-Host/PHP_Image.git\r\n\r\nThen, install a local copy of this component's dependencies to complete the\r\ndevelopment environment:\r\n\r\n    # build vendor/ folder\r\n    phing build-vendor\r\n\r\nTo make life easier for you, common tasks (such as running unit tests,\r\ngenerating code review analytics, and creating the PEAR package) have been\r\nautomated using [phing](http://phing.info).  You'll find the automated steps\r\ninside the build.xml file that ships with the component.\r\n\r\nRun the command 'phing' in the component's top-level folder to see the full list\r\nof available automated tasks.\r\n\r\nLicense\r\n-------\r\n\r\nSee LICENSE.txt for full license details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}